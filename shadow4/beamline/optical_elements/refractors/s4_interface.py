import numpy

from syned.beamline.element_coordinates import ElementCoordinates
from syned.beamline.optical_elements.refractors.interface import Interface

from shadow4.beam.s4_beam import S4Beam
from shadow4.beamline.s4_beamline_element import S4BeamlineElement

class S4Interface(Interface):

    def __init__(self,
                 name="Undefined",
                 boundary_shape=None,
                 surface_shape=None,
                 material_object=None,  # just a name, not used
                 material_image=None,   # just a name, not used
                 f_r_ind = 0,
                 r_ind_obj = 1.0,
                 r_ind_ima = 1.0,
                 r_attenuation_obj = 0.0,
                 r_attenuation_ima = 0.0,
                 file_r_ind_obj = "",
                 file_r_ind_ima = "",
                 ):

        """
        f_r_ind: source of optical constants, from
                          constant value or PREREFL preprocessor (file):
                          (0) constant value in both object and image spaces
                          (1) file in object space, constant value in image space
                          (2) constant value in object space, file in image space
                          (3) file in both object and image space

        r_ind_obj	(for f_r_ind=0,2): index of refraction in object space.
        r_ind_ima	(for f_r_ind=0,1): index of refraction in image space.
        r_attenuation_obj	(for f_r_ind=0,2): attenuation coefficient in object space. Units of UserUnitLength^(-1)
        r_attenuation_ima	(for f_r_ind=0,1): attenuation coefficient in image space. Units of UserUnitLength^(-1)
        file_r_ind_obj	    (for f_r_ind=1,3): file generated by PREREFL
        file_r_ind_ima	    (for f_r_ind=2,3): file generated by PREREFL
        """

        Interface.__init__(self,
                        name=name,
                        surface_shape=surface_shape,
                        boundary_shape=boundary_shape,
                        material_object=material_object,
                        material_image=material_image,
                        )


        self._f_r_ind = f_r_ind
        self._r_ind_obj = r_ind_obj
        self._r_ind_ima = r_ind_ima
        self._r_attenuation_obj = r_attenuation_obj
        self._r_attenuation_ima = r_attenuation_ima
        self._file_r_ind_obj = file_r_ind_obj
        self._file_r_ind_ima = file_r_ind_ima

    def get_refraction_indices(self):
        if self._f_r_ind == 0:
            refraction_index_object = self._r_ind_obj
            refraction_index_image  = self._r_ind_ima
        elif self._f_r_ind == 1:
            raise Exception(NotImplementedError)
        elif self._f_r_ind == 2:
            raise Exception(NotImplementedError)
        elif self._f_r_ind == 3:
            raise Exception(NotImplementedError)
        else:
            raise Exception(NotImplementedError)

        return refraction_index_object, refraction_index_image

class S4InterfaceElement(S4BeamlineElement):
    def __init__(self,
                 optical_element : S4Interface = None,
                 coordinates : ElementCoordinates = None,
                 input_beam : S4Beam = None):
        super().__init__(optical_element=optical_element if optical_element is not None else S4Interface(),
                         coordinates=coordinates if coordinates is not None else ElementCoordinates(),
                         input_beam=input_beam)

    def trace_beam(self, **params):
        flag_lost_value = params.get("flag_lost_value", -1)

        p = self.get_coordinates().p()
        q = self.get_coordinates().q()
        theta_grazing1 = numpy.pi / 2 - self.get_coordinates().angle_radial()
        theta_grazing2 = numpy.pi / 2 - self.get_coordinates().angle_radial_out()
        alpha1 = self.get_coordinates().angle_azimuthal()

        #
        input_beam = self.get_input_beam().duplicate()
        #
        # put beam in mirror reference system
        #
        input_beam.rotate(alpha1, axis=2)
        input_beam.rotate(theta_grazing1, axis=1)
        input_beam.translation([0.0, -p * numpy.cos(theta_grazing1), p * numpy.sin(theta_grazing1)])

        #
        # reflect beam in the mirror surface
        #
        soe = self.get_optical_element() #._optical_element_syned
        # print(">>> CCC", soe.get_surface_shape().get_conic_coefficients())

        # TODO: no check for total reflection is done...
        # TODO: implement correctly in shadow4 via Fresnel equations for the transmitted beam

        footprint, normal = self.apply_local_refraction(input_beam)

        #
        # apply mirror boundaries
        #
        footprint.apply_boundaries_syned(soe.get_boundary_shape(), flag_lost_value=flag_lost_value)
        #
        # TODO" apply lens absorption
        #

        #
        # from element reference system to image plane
        #

        output_beam = footprint.duplicate()
        _, n2 = self.get_optical_element().get_refraction_indices()
        output_beam.change_to_image_reference_system(theta_grazing2, q, refraction_index=n2)

        return output_beam, footprint

    def apply_local_refraction(self, beam):
        raise NotImplementedError()


if __name__ == "__main__":
    pass
